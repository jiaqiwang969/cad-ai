---
description: 
globs: 
alwaysApply: true
---
# Make Test-09-1 完整数据流程规则

本规则详细描述 `make test-09-1` 从网页数据源获取到JSON输出的完整流程，包含每个步骤的具体代码位置和实现逻辑。

## 🎯 核心文件位置

主要实现文件：[test/09-1-test_product_specifications_extractor.py](mdc:test/09-1-test_product_specifications_extractor.py)

## 🌐 1. 数据源获取过程

### A. 浏览器初始化 - `prepare_driver()` (第89行)
```python
# 位置: test/09-1-test_product_specifications_extractor.py:89
def prepare_driver():
    opt = Options()
    opt.add_argument('--headless')  # 无头模式
    opt.add_argument('--no-sandbox')
    opt.add_argument('--disable-dev-shm-usage')
    opt.add_argument('--window-size=1920,1080')
    opt.add_argument('--user-agent=Mozilla/5.0...')  # 伪装为真实浏览器
    return webdriver.Chrome(options=opt)
```

### B. 页面访问与预处理 - `main()` (第1529行)
```python
# 位置: test/09-1-test_product_specifications_extractor.py:1529
# 核心步骤:
# 1. 访问产品页面: driver.get(PRODUCT_URL)
# 2. 设置显示全部: items_per_page_success = set_items_per_page_to_all(driver)
# 3. 确保页面加载: scroll_page_fully(driver)
```

### C. 动态内容加载处理 - `set_items_per_page_to_all()` (第139行)
```python
# 位置: test/09-1-test_product_specifications_extractor.py:139-467
# 三种策略尝试显示所有产品:
# - 策略1: 查找分页控件
# - 策略2: 查找当前页数控件
# - 策略3: 检查所有select元素
```

## 🔍 2. 智能表格识别与数据提取

### 主函数 - `extract_all_product_specifications()` (第468行)
```python
# 位置: test/09-1-test_product_specifications_extractor.py:468
# 返回值: (specifications, all_tables_data)
```

### A. 页面元素分析 (第488-547行)
```python
# 等待页面稳定: time.sleep(1 if FAST_MODE else 3)
# 完整滚动页面: scroll_page_fully(driver)
# 检测动态内容: pagination_indicators = ["items per page", "out of", "total"]
```

### B. 动态加载策略 (第548-650行)
```python
# 六种动态加载策略:
# 1. 延长等待时间: time.sleep(10)
# 2. 强制刷新页面: driver.refresh()
# 3. 多次滚动触发懒加载
# 4. 查找并点击加载触发器
# 5. 等待特定元素出现: WebDriverWait(driver, 15).until(...)
# 6. 最终滚动和等待
```

### C. 表格完整分析 (第651-761行)
```python
# 为每个表格构建数据结构:
table_data = {
    'table_index': i + 1,
    'table_type': 'unknown',  # 'vertical' 或 'horizontal'
    'total_rows': len(table_rows),
    'headers': [],
    'data_rows': [],
    'raw_data': [],
    'is_product_table': False,
    'table_context': ''
}
```

### D. 智能表格选择 (第813-920行)
```python
# 两种选择策略:
# 1. 通过标题查找 (优先级最高)
product_section_keywords = [
    'product selection', 'product list', 'product specifications',
    'produktauswahl', 'produktliste',  # 德语
    'sélection de produits',  # 法语
    '产品选择', '产品列表'  # 中文
]

# 2. 表格评分系统 (备选方案)
# 评分标准: 非空单元格数量 + 产品编号相关词汇 + 产品编号格式
```

## 📊 3. 产品规格数据提取

### A. 表格类型检测 (第970-1020行)
```python
# 检测表格类型逻辑:
two_col_count = 0
for i, row in enumerate(rows[:5]):
    cells = row.find_elements(By.CSS_SELECTOR, 'td, th')
    if len(cells) == 2:
        two_col_count += 1

if two_col_count >= 3:  # 如果至少3行都是2列
    is_vertical_table = True  # 纵向表格（属性-值对）
else:
    is_vertical_table = False  # 横向表格（列表格式）
```

### B. 纵向表格处理 (第1020-1050行)
```python
# 纵向表格提取逻辑:
if is_vertical_table:
    for i, row in enumerate(rows):
        prop_name = cells[0].text.strip()    # 属性名
        prop_value = cells[1].text.strip()   # 属性值
        
        if is_likely_product_reference(prop_value):
            spec_info = {
                'reference': prop_value,
                'property_name': prop_name,
                'table_type': 'vertical'
            }
```

### C. 横向表格处理 (第1050-1200行)
```python
# 横向表格处理步骤:
# 1. 查找表头行 (第1057-1069行)
# 2. 确定产品编号列 (第1071-1095行)
# 3. 提取数据行 (第1097-1200行)

# 产品编号列识别关键词:
keywords = [
    'part number', 'part no', 'product number', 'model',
    'reference', 'item number', 'description',
    'bestellnummer', 'artikelnummer',  # 德语
    'numéro', 'référence',  # 法语
    'número', 'codigo',  # 西班牙语
    '型号', '编号', '料号'  # 中文
]
```

### D. 智能产品编号识别 - `is_likely_product_reference()` (第1249行)
```python
# 位置: test/09-1-test_product_specifications_extractor.py:1249
# 评分算法:
positive_indicators = 0

# 1. 包含数字 (+2分)
if any(c.isdigit() for c in text):
    positive_indicators += 2

# 2. 包含连字符或下划线 (+1分)
if '-' in text or '_' in text:
    positive_indicators += 1

# 3. 包含大写字母 (+1分)
if any(c.isupper() for c in text[1:]):
    positive_indicators += 1

# 4. 长度适中 (+1分)
if 2 <= len(text) <= 50:
    positive_indicators += 1

# 5. 特殊格式模式 (+2分)
special_patterns = [
    r'^\d+-\d+-\d+$',  # 5-14230-00
    r'^[A-Z]+\d+',     # SLS50, DIN787
    r'^[A-Z0-9]+[-_][A-Z0-9]+',  # QAAMC10A050S
]

return positive_indicators >= 3  # 总分>=3分认为是产品编号
```

## 🔗 4. URL生成与数据结构化

### 规格URL生成 - `generate_specification_urls()` (第1397行)
```python
# 位置: test/09-1-test_product_specifications_extractor.py:1397
def generate_specification_urls(base_info, specifications):
    for spec in specifications:
        # 关键步骤: 添加PartNumber查询参数
        query_params = base_info['query_params'].copy()
        query_params['PartNumber'] = [reference]
        
        # 构建完整URL
        spec_url = f"{base_info['base_url']}{base_info['base_path']}?{query_string}"
```

### 基础产品信息提取 - `extract_base_product_info()` (第1371行)
```python
# 位置: test/09-1-test_product_specifications_extractor.py:1371
# URL解析逻辑:
parsed_url = urlparse(product_url)
path_parts = parsed_url.path.split('/')

return {
    'base_product_name': path_parts[-1],  # URL路径最后一部分
    'product_id': query_params.get('Product', ['unknown-id'])[0],  # Product参数
    'query_params': query_params  # 完整查询参数
}
```

## 📋 5. JSON数据构建 (核心标准格式)

### 主保存函数 - `save_results()` (第1445行)
```python
# 位置: test/09-1-test_product_specifications_extractor.py:1445
def save_results(base_info, specifications, spec_urls, all_tables_data=None):
    # 构建流程分为5个步骤
```

### A. 表头提取 (第1448-1455行)
```python
# 🎯 1. 查找横向表格的表头
table_headers = []
horizontal_table = None

if all_tables_data:
    for table in all_tables_data:
        if table['table_type'] == 'horizontal' and table.get('headers'):
            table_headers = [h for h in table['headers'] if h.strip()]  # 去掉空列名
            horizontal_table = table
            break
```

### B. 规格数据映射 (第1457-1481行)
```python
# 🎯 2. 构建简化的规格列表
simplified_specs = []
for i, spec in enumerate(specifications):
    spec_data = {
        'reference': spec.get('reference', ''),
        'url': spec_urls[i]['url'] if i < len(spec_urls) else '',
        'parameters': {}
    }
    
    # 3. 从原始表格数据中提取参数
    if horizontal_table and spec.get('all_cells'):
        all_cells = spec['all_cells']
        headers = horizontal_table['headers']
        
        # 将单元格数据映射到表头
        for j, header in enumerate(headers):
            if header.strip() and j < len(all_cells):
                # 🔧 跳过各种语言的产品编号列名
                header_lower = header.lower()
                reference_keywords = ['part number', 'référence', 'reference', 'teil nr', 'numero parte']
                
                if not any(keyword in header_lower for keyword in reference_keywords):
                    cell_value = all_cells[j].strip()
                    if cell_value:  # 只保存非空值
                        spec_data['parameters'][header] = cell_value
    
    simplified_specs.append(spec_data)
```

### ⭐ C. 标准JSON构建 (第1483-1491行) - **核心代码**
```python
# 🎯 4. 构建最终的简化结果 - test-09-1标准格式
simple_results = {
    'extraction_time': time.strftime('%Y-%m-%d %H:%M:%S'),  # 当前时间戳
    'base_product': {
        'name': base_info['base_product_name'],  # URL路径提取
        'id': base_info['product_id'],           # Product查询参数
        'url': PRODUCT_URL                       # 原始URL
    },
    'table_headers': table_headers,              # 横向表格表头
    'total_specifications': len(specifications), # 原始规格数量
    'specifications': simplified_specs           # 处理后的规格数组
}
```

### D. 文件保存 (第1493-1500行)
```python
# 🎯 5. 保存简化的JSON文件
import os
current_dir = os.getcwd()

json_file = RESULTS_DIR / f"product_specs_{timestamp}.json"
json_full_path = os.path.join(current_dir, json_file)
with open(json_file, 'w', encoding='utf-8') as f:
    json.dump(simple_results, f, indent=2, ensure_ascii=False)

print(f"💾 简化结果已保存到: {json_full_path}")
```

## 🚨 6. 格式标准化问题与修复方案

### ✅ 标准test-09-1格式示例
```json
{
  "extraction_time": "2025-06-07 08:46:03",
  "base_product": {
    "name": "fibrotubi-orchidea-brick-wall-single-opening-sp105",
    "id": "90-04092023-049404",
    "url": "https://www.traceparts.cn/en/product/..."
  },
  "table_headers": ["Part Number", "Description", "Model", "Height (mm)", ...],
  "total_specifications": 14,
  "specifications": [
    {
      "reference": "BASE060X200",
      "url": "https://www.traceparts.cn/en/product/...&PartNumber=BASE060X200",
      "parameters": {
        "Description": "Orchidea Brick wall Single Opening sp105 : 060 x 200",
        "Model": "Orchidea - Base",
        "Height (mm)": "200",
        "Width (mm)": "60"
      }
    }
  ]
}
```

### ❌ Pipeline格式问题 (需要修复)
```json
{
  "specifications": [
    {
      "reference": "...",
      "url": "...",
      "dimensions": "...",          // 🔴 额外字段 - 应删除
      "weight": "...",             // 🔴 额外字段 - 应删除
      "table_type": "...",         // 🔴 额外字段 - 应删除
      "row_index": 0,              // 🔴 额外字段 - 应删除
      "parameters": {...},
      "extraction_method": "...",   // 🔴 额外字段 - 应删除
      "leaf_category": {...}       // 🔴 额外字段 - 应删除
    }
  ]
}
```

### 🔧 修复方案位置
位置：[src/pipelines/cache_manager.py](mdc:src/pipelines/cache_manager.py) 第448-467行

修复代码：
```python
# 🎯 完全按照test-09-1标准格式，移除所有额外字段
test_09_1_spec = {
    'reference': spec.get('reference', ''),
    'url': spec_urls[0] if spec_urls else product_url,
    'parameters': spec.get('parameters', {})  # 🎯 只保留这3个核心字段
}
```

## 🎯 完整数据流向

```
产品URL输入
    ↓ (main函数 - 第1529行)
浏览器初始化 (prepare_driver - 第89行)
    ↓
页面访问与预处理 (set_items_per_page_to_all - 第139行)
    ↓
动态内容检测与加载 (第548-650行)
    ↓
表格智能识别 (第813-920行)
    ↓ (extract_all_product_specifications - 第468行)
表格类型判断 (第970-1020行)
    ↓
产品编号列识别 & 规格数据提取 (第1050-1200行)
    ↓ (is_likely_product_reference - 第1249行)
智能产品编号识别
    ↓ (generate_specification_urls - 第1397行)
专用URL生成
    ↓ (save_results - 第1445行)
参数映射 & JSON构建 (第1483-1491行) ⭐ 核心
    ↓
文件保存与输出 (第1494-1500行)
```

## 🔗 7. 关键依赖数据结构

### 输入数据依赖
1. **`base_info`** - 来自 `extract_base_product_info(PRODUCT_URL)`
2. **`specifications`** - 来自 `extract_all_product_specifications(driver, product_id)`  
3. **`spec_urls`** - 来自 `generate_specification_urls(base_info, specifications)`
4. **`all_tables_data`** - 来自 `extract_all_product_specifications()`的第二个返回值
5. **`PRODUCT_URL`** - 全局变量，原始产品URL

### 输出标准字段
```python
# test-09-1标准格式必需字段：
required_fields = {
    'extraction_time',      # 时间戳
    'base_product',         # 基础产品信息
    'table_headers',        # 表头数组
    'total_specifications', # 规格总数
    'specifications'        # 规格数组
}

# 每个specification必需字段：
spec_required_fields = {
    'reference',    # 产品编号
    'url',         # 专用URL
    'parameters'   # 参数字典
}
```

## 🌟 关键技术特性

1. **多语言支持**: 支持英语、法语、德语、西班牙语、中文的产品编号识别
2. **智能表格识别**: 通过标题匹配和评分系统自动选择最佳表格
3. **动态内容处理**: 6种策略处理AJAX动态加载
4. **灵活表格处理**: 自适应纵向（属性-值）和横向（列表）两种格式
5. **智能产品编号识别**: 基于多维度评分的算法判断
6. **完整数据保留**: 保存原始表格结构和完整单元格数据
7. **标准格式输出**: 严格按照test-09-1格式输出JSON

## 🔧 调试与诊断

### Debug模式相关代码位置
- HTML源码保存: 第508-515行
- 页面截图保存: 第1223-1230行
- 详细日志输出: 第762-800行
- 产品编号识别debug: 第1249行函数内

### 性能优化相关
- FAST_MODE检查: 全局变量，影响多个位置的执行逻辑
- 缓存机制: 第473-487行 (读取) 和 第1201-1213行 (保存)
- 时间戳控制: 第16-19行全局打印时间戳设置

## 🎯 Pipeline集成指南

### 完全复制test-09-1格式的关键步骤：
1. **保持表头提取逻辑**: 从横向表格中提取`table_headers`
2. **保持参数映射逻辑**: 跳过产品编号列，只保存非空值
3. **严格按照JSON结构**: 只保留3个核心字段 (`reference`, `url`, `parameters`)
4. **保持URL生成逻辑**: 添加`PartNumber`查询参数
5. **保持时间戳格式**: 使用`time.strftime('%Y-%m-%d %H:%M:%S')`
